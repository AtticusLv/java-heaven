<!-- TOC -->

- [Redis概述](#redis概述)
- [为什么使用Redis/缓存](#为什么使用redis缓存)
- [为什么使用Redis而不用Map/Guava做缓存](#为什么使用redis而不用mapguava做缓存)
    - [Redis线程模型](#redis线程模型)
- [Redis和Memcached区别](#redis和memcached区别)

<!-- /TOC -->

# Redis概述
Redis数据是存在内存中的，读写非常快。Redis被广泛应用于缓存使用、分布式锁。Redis支持事务、持久化、LUA脚本、LRU驱动时间、多种集群方案。

# 为什么使用Redis/缓存
- 高性能
- 高并发
# 为什么使用Redis而不用Map/Guava做缓存
缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。

使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。

## Redis线程模型
[参考地址](https://www.javazhiyin.com/22943.html)

单线程工作模型

redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。

文件事件处理器的结构包含 4 个部分：

多个 socket
IO 多路复用程序
文件事件分派器
事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）
多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

```
- 纯内存操作
- 核心是基于非阻塞的 IO 多路复用机制
- 单线程反而避免了多线程的频繁上下文切换问题
```
# Redis和Memcached区别
